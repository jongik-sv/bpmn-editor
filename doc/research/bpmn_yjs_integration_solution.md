# BPMN.io (bpmn-js)와 Yjs 통합 시 UI 끊김 현상 해결 방안 연구

## 1. 문제 진술

`bpmn-js` (또는 `bpmn-io` 에디터)와 `Yjs`를 사용하여 실시간 협업 기능을 구현할 때, Yjs를 통해 변경 사항이 발생하고 이를 에디터에 반영하는 과정에서 UI가 끊기거나 컨텍스트 메뉴가 갑자기 사라지는 등의 문제가 발생합니다. 이는 주로 Yjs의 변경 사항을 반영하기 위해 BPMN XML 문서 전체를 `bpmn-js`의 `importXML` 또는 `importDiagram` 함수로 재로드(re-import)하기 때문에 발생합니다.

## 2. 전체 재로드(Full Re-import)가 문제가 되는 이유

`bpmn-js`는 복잡한 내부 상태를 관리하는 대화형 에디터입니다. `importXML`과 같은 함수는 에디터의 모든 요소를 파싱하고 다시 렌더링하는 과정을 거칩니다. 이 과정은 다음과 같은 문제를 야기합니다:

*   **UI 끊김 및 깜빡임**: 전체 에디터가 다시 그려지면서 시각적인 끊김 현상이 발생합니다.
*   **사용자 경험 저하**: 사용자가 요소를 선택하거나 컨텍스트 메뉴를 열어둔 상태에서 재로드가 발생하면, 해당 UI 요소들이 사라지거나 초기화되어 작업 흐름이 방해받습니다.
*   **성능 저하**: 작은 변경에도 불구하고 전체 문서를 파싱하고 렌더링하는 것은 비효율적이며, 문서의 크기가 커질수록 성능 문제가 심화됩니다.
*   **내부 상태 손실**: 에디터의 선택 상태, 줌 레벨, 스크롤 위치 등 사용자의 상호작용으로 인한 내부 상태가 재로드 시 초기화될 수 있습니다.

## 3. 제안된 해결책: `bpmn-js` 모델링 API를 통한 세분화된 업데이트 (Granular Updates)

가장 이상적인 해결책은 Yjs에서 발생한 변경 사항을 `bpmn-js` 에디터의 내부 모델에 직접적이고 세분화된 방식으로 적용하는 것입니다. `bpmn-js`는 `modeling` 서비스를 통해 요소의 생성, 이동, 삭제, 속성 변경 등 다양한 작업을 프로그래밍 방식으로 수행할 수 있는 강력한 API를 제공합니다.

### 3.1. 작동 방식 개념

1.  **Yjs 변경 감지**: Yjs의 `Y.Doc` 또는 특정 `Y.Map`, `Y.Array`와 같은 데이터 구조에 리스너를 설정하여 변경 사항을 감지합니다.
2.  **BPMN 요소 매핑**: Yjs에서 발생한 일반적인 데이터 변경(예: 텍스트 변경, 배열 요소 추가/삭제)을 어떤 BPMN 요소(태스크, 게이트웨이, 시퀀스 플로우 등)의 어떤 속성(이름, 위치, 연결 등)이 변경되었는지 해석합니다. 이 과정이 가장 중요하고 복잡할 수 있습니다.
3.  **`bpmn-js` 모델링 API 호출**: 해석된 변경 사항을 기반으로 `bpmn-js`의 `modeling` 서비스(예: `modeling.updateProperties`, `modeling.moveShape`, `modeling.removeElements`, `modeling.createShape`, `modeling.connect`)를 호출하여 해당 변경 사항만 에디터에 반영합니다.

### 3.2. 장점

*   **매끄러운 UI**: 전체 재로드가 없으므로 UI 끊김이나 깜빡임이 발생하지 않습니다.
*   **향상된 사용자 경험**: 사용자의 작업 흐름이 방해받지 않고, 선택 상태나 컨텍스트 메뉴 등이 유지됩니다.
*   **성능 최적화**: 필요한 부분만 업데이트하므로 대규모 문서에서도 효율적입니다.
*   **정확한 상태 유지**: 에디터의 내부 상태가 불필요하게 초기화되지 않습니다.

### 3.3. 과제 및 고려사항

*   **변경 해석의 복잡성**: Yjs의 일반적인 데이터 변경을 BPMN의 특정 모델링 작업으로 정확히 매핑하는 로직을 구현하는 것이 가장 큰 과제입니다. 특히 복합적인 변경(예: 그룹 이동 시 내부 요소들도 함께 이동)이나 구조적인 변경(예: 서브 프로세스 추가/삭제)은 더욱 복잡합니다.
*   **`bpmn-js` API 숙지**: `bpmn-js`의 `modeling` API와 내부 모델 구조에 대한 깊은 이해가 필요합니다.
*   **동시성 문제**: 여러 사용자가 동시에 같은 요소를 변경할 때, Yjs의 CRDT가 데이터 충돌을 해결하더라도, `bpmn-js` 모델링 API 호출 순서나 타이밍에 따라 UI 상의 미묘한 문제가 발생할 수 있습니다.

## 4. 대안 해결책: XML Diffing 및 패치

세분화된 모델링 API 접근 방식이 너무 복잡하거나 구현하기 어려운 경우, 차선책으로 XML Diffing (XML 차이점 비교) 및 패치 방식을 고려할 수 있습니다.

### 4.1. 작동 방식 개념

1.  **XML 상태 유지**: `bpmn-js` 에디터의 현재 XML 상태와 Yjs를 통해 동기화된 최신 XML 상태를 모두 유지합니다.
2.  **XML Diff 생성**: 두 XML 문서 간의 차이점(diff)을 생성합니다. 이 과정에서 `xml-diff`와 같은 라이브러리를 활용할 수 있습니다.
3.  **Diff 해석 및 적용**: 생성된 XML diff를 해석하여 어떤 BPMN 요소가 추가/삭제/변경되었는지 파악하고, 이를 `bpmn-js`의 `modeling` API를 통해 적용합니다.

### 4.2. 장점

*   **구현 복잡성 분리**: Yjs 변경을 직접 BPMN 모델링으로 매핑하는 대신, XML diff라는 중간 단계를 거치므로 로직의 복잡성을 분리할 수 있습니다.

### 4.3. 과제 및 고려사항

*   **XML Diffing의 복잡성**: 정확하고 효율적인 XML diff를 생성하는 것이 쉽지 않습니다. 특히 BPMN XML은 구조가 복잡하여 의미 있는 diff를 추출하기 어려울 수 있습니다.
*   **성능 오버헤드**: XML 파싱 및 diff 생성 과정에서 성능 오버헤드가 발생할 수 있습니다.
*   **Diff를 모델링 API로 변환**: 생성된 XML diff를 다시 `bpmn-js`의 `modeling` API 호출로 변환하는 로직이 여전히 필요하며, 이 또한 복잡할 수 있습니다.

## 5. 구현 권장 사항

1.  **세분화된 모델링 API 접근 방식 우선 고려**: 가능하면 `bpmn-js`의 `modeling` API를 직접 활용하는 방식을 우선적으로 시도하는 것이 성능과 사용자 경험 측면에서 가장 좋습니다.
2.  **점진적 구현**: 모든 BPMN 요소와 속성에 대한 변경을 한 번에 구현하기보다는, 가장 빈번하게 발생하는 변경(예: 요소 이름 변경, 이동)부터 시작하여 점진적으로 기능을 확장합니다.
3.  **기존 라이브러리/예제 탐색**: `bpmn-js`와 Yjs를 함께 사용하는 오픈 소스 프로젝트나 예제가 있는지 탐색하여 참고합니다. (예: `y-prosemirror`와 같은 다른 Yjs 통합 라이브러리에서 아이디어를 얻을 수 있습니다.)
4.  **테스트**: 변경 사항이 정확하게 반영되고 UI 문제가 발생하지 않는지 철저히 테스트합니다. 특히 동시 편집 시나리오를 중점적으로 테스트해야 합니다.

## 6. 결론

`bpmn-js`와 `Yjs`를 통합할 때 발생하는 UI 끊김 현상은 전체 XML 재로드 방식에서 비롯됩니다. 이를 해결하기 위해서는 Yjs의 변경 사항을 `bpmn-js`의 `modeling` API를 통해 세분화된 방식으로 적용하는 것이 핵심입니다. 이는 구현에 복잡성이 따르지만, 사용자 경험과 성능 측면에서 훨씬 우월한 결과를 가져올 것입니다. XML diffing은 대안이 될 수 있지만, 그 자체로 또 다른 복잡성을 내포합니다. 신중한 설계와 점진적인 구현을 통해 이 문제를 효과적으로 해결할 수 있습니다.